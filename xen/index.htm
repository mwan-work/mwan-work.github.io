
<!DOCTYPE html>
<html>
<head>
  <title>XEN Tool</title>
  
  <style>
body {
  background-color: #f5f5f5; /* Light grey color */
}
.container {
  display: flex;

}
.selectxpathdiv.highlighted {
  background-color: #D3D3D3; /* Change this to your preferred highlight color */
}


.top-div {
  position: fixed; 
  top: 50px; 
  left: 50px; 
  width: 90%;
  background-color: #f1f1f1;
  padding: 20px;
  z-index: 9999; 
  display: none;
}




.right-container {
  display: flex;
  flex-direction: column;
  flex-grow: 1; 
  width: 50%;
}

.centre-container {
  display: flex;
  flex-direction: column;
  flex-grow: 1; 
  width: 100%;
}



.rule-container {
  display: flex;
  flex-direction: column;
  flex-grow: 1; 
  width: 85%;
}

.control-container {
  display: flex;
  flex-direction: column;
  flex-grow: 1; 
  width: 15%;
}

.line {

}

.line.highlighted {
    background-color: #333333;
    color: yellow;
    
}
.tag {
    font-weight: bold;
   
}


    #topbanner {
      width: 100%;
      height: 80px;
	  background-color: purple;
	  border: 1px solid purple;
	  color: white;
	  font-weight: bold;
    }

    #xmlInput {
      width: 95%;
      height: 150px;
	  resize: vertical;
    }
    #tidyButton {
      margin-top: 10px;
    }
	#outputArea {
    background-color: black;
    color: white; 
	font-size: 16px;
  
	overflow: auto;
        width: 99%;
      height: 400px;
	  border: 1px solid darkgrey; 
	  
  }

 #selectXPath {
  	overflow: auto;
        width: 100%;
      height: 100px;
    font: 16px Consolas; 
    font-weight: bold; 
	border: 1px solid darkgrey; 
	background-color: white;
    
  }

  /* Styles for the outputXPath */
  #outputXPath {
  	overflow: auto;
        width: 100%;
      height: 258px;
    font: 16px Consolas;
    font-weight: bold;
	border: 1px solid darkgrey; 
	background-color: black;
    color: white; 
	white-space: nowrap;
    
  }
  
  #outputRule{
  	overflow: auto;
        width: 100%;
      height: 225px;
    font: 16px Consolas; 
    font-weight: bold; 
	border: 1px solid darkgrey; 
	background-color: white;
    white-space: pre; /* This ensures whitespace is preserved */
  }
  
  
  #outputXPath2 {
    display: none;
	height: 1px;
}
  
  #validationMessage {
      color: red; 
    }
  </style>
</head>
<body>
<div id="topbanner"><font size=12>Xpath Extraction and Normalization tool </font><br>
<font size=4>for ExLibris Primo VE</font>
</div>
<br>
<div class="container">
<div class="right-container"><p>
<b>[1] XML Record:</b><br>
  <textarea id="xmlInput" placeholder="Enter XML record here" oninput="enableButtonIfTextareaNotEmpty()"></textarea>
  </p>
  </div>
  <div class="right-container">
  <p>
  <b>Instructions:</b><br>
  1) XML record goes into the <b>[1]XML Record</b> box on the left.<br>
  2) Click the <b>[Format XML and Extract XPath]</b> button.<br>
  3) Select an element in <b>[Formatted XML]</b> to show the XPath.<br>
  4) Create an XML normalization rule using the <b>[XML Normalization Rule Builder]</b>.
  </p>
  <p>Test with random record:<br>  
  
  <button onclick="generateRandomXML3()">Generic XML</button> <button onclick="generateRandomXML2()">OAI_DC</button> 
  <button onclick="generateRandomXML1()">EAD</button><br>
  </p>
  
  </div>
  </div>
  <div id="validationMessage">XML Validation:</div><br>
  
  <button id="singleButton" disabled>Format XML and Extract XPath</button>
  
 
 
  <button onclick="clearXMLInput()">RESET</button>
<br><br>


<div class="container">

<div class="right-container">
<div style="background-color: darkblue; color: white;border: 1px solid; border-color: darkgrey; width: 99%">
<span style="float: left;"><b>[2] Formatted XML</b> </span><span style="float: right;">Colour: <button id="nocolour" onclick="nocolourTags()" disabled>Remove</button> <button id="recolour" onclick="recolorizeTags()" disabled>Redo</button></span></div>
 <div id="outputArea"></div>
 </div>
  
  
  <div class="right-container">
  	<div style="background-color: darkblue; color: white;border: 1px solid; border-color: darkgrey; width: 100%">
	<span style="float: left;"><b>[3] Xpath List</b></span><span style="float: right;">Occurence: <button id="occnumberON" onclick="replaceXPath()" disabled>On</button><button id="occnumberOFF" onclick="removeNumbersInSquareBrackets()" disabled>Off</button></span>
	</div>
    <div id="outputXPath"></div>
	<br>
  <div style="background-color: darkblue; color: white;border: 1px solid; border-color: darkgrey; width: 100%"><span style="float: left;"><b>[4] Choose an Xpath</b></span><span style="float: right;">Copy to Normalization Rule: <button id="btn_copyxpathtocondition" onclick="copyxpathtoCondition(document.querySelector('.selectxpathdiv.highlighted'))" disabled><font color="blue">&#9632;</font>
Condition</button> <button id="btn_copyxpathtofunction" onclick="copyxpathtoFunction(document.querySelector('.selectxpathdiv.highlighted'))" disabled><font color="red">&#9650;</font>
Action</button> &nbsp;|&nbsp;&nbsp;<button id="btn_copyxpath" onclick="copyHighlightedText()" disabled>Copy to Clipboard</button></span></div>
    <div id="selectXPath"></div>
	

	
  </div>
</div>
<br>

<div class="container">

<div class="rule-container">
<div style="background-color: darkblue; color: white;border: 1px solid; border-color: darkgrey; width: 100%"><span style="float: left;"><b>[5] XML Normalization Rule Builder</b></span>&nbsp;&nbsp;|&nbsp;&nbsp;<span style="float: right;"><button id="btn_copyrule" onclick="copyOutputRule()" disabled>Copy to Clipboard</button></span></div>
  <div id="outputRule" contenteditable="true" spellcheck="false"></div>

 
 </div>
  
  
  <div class="control-container">
  	<div style="background-color: darkblue; color: white;border: 1px solid; border-color: darkgrey; width: 100%; height:100%">
&emsp;<b>CONDITION:</b><br>
&emsp;<select id="list_when" onchange="generateRuleFromHighlightedRow()" class='form-control'>
  <option>true</option>
<option>exist</option>
<option>equals</option>
<option>starts with</option> 
<option>contains (case)</option>
<option>contains (non-case)</option>
 </select>
 <br><br>
 &emsp;<b>ACTION:</b><br>
 &emsp;<select id="list_function" onchange="generateRuleFromHighlightedRow()" class='form-control'>
  <option>copy</option>
  <option>copy (starts with)</option>
<option>set value</option>
<option>set to TEMP</option>
</select>
<br><br>

&emsp;<b>TRANSFORM:</b><br>
&emsp;<select id="list_transform" onchange="generateRuleFromHighlightedRow()" class='form-control' disabled>
  
  <option>convert to lower case</option>  
  <option>convert to upper case</option>
  <option>convert to title case</option>
  <option>convert to URL link</option>
  <option>remove leading and trailing</option>
<option>remove numbers</option>
<option>remove brackets</option>
</select><br>
&emsp;<button id="btn_transformadd" onclick="addLine()" disabled>Add</button> <button id="btn_transformremove" onclick="removeLine()" disabled>Remove</button>

<br><br>


&emsp;<b>TARGET:</b><br>
&emsp;<select id="list_fields" onchange="generateRuleFromHighlightedRow()" class='form-control'>
  <option disabled style="font-style:italic">--------</option> 
<option disabled style="font-style:italic">Dublin Core</option>
<option disabled style="font-style:italic"></option>
<option>dc:identifier</option>
<option>dc:title</option>
<option>dc:creator</option>
<option>dc:subject</option>
<option>dc:description</option>
<option>dc:publisher</option>
<option>dc:contributor</option>
<option>dc:date</option>
<option>dc:type</option>
<option>dc:format</option>
<option>dc:source</option>
<option>dc:language</option>
<option>dc:relation</option>
<option>dc:coverage</option>
<option>dc:rights</option>

<option disabled style="font-style:italic">--------</option>
<option disabled style="font-style:italic">Other</option>
<option disabled style="font-style:italic"></option>
<option>local field</option>
<option>resource type</option>



</select></div>

	
  </div>
</div>


<div id="outputXPath2"></div>

</div>



<script>

//TEST
// Initialize the array to hold the lines of text
let transformLine = [];
let transformText =`    <font color="gray"><i>##Insert transformation actions here</i></font>`;
let transformCounter=0;
// Variable to store the combined text


// Function to add the string 'LineXYZ' to the array
function addLine() {
	var list_transform = document.getElementById('list_transform');
	var selectedTransform = list_transform.value;
    let newLine;
	let lineNumber = transformLine.length + 1;
	
	if(selectedTransform==='remove leading and trailing'){
		newLine =`<font color="gray"><i>    #TRANSFORM ${lineNumber}: Remove leading and trailing spaces.</i></font>
    remove leading and trailing spaces (TEMP"1")<br>`
	} else if(selectedTransform==='convert to URL link'){
		newLine =`<font color="gray"><i>    #TRANSFORM ${lineNumber}: Convert into clickable URL link. Only works if value is URL address.</i></font> 
    set TEMP"2" to xpath "<font color="red">${amendedXPathFunction}</font>"
    add prefix (TEMP"1","&lt;a href=\\"")
    add suffix (TEMP"1","\\" target=\\"_blank\\">")
    concatenate with delimiter (TEMP"1",TEMP"2","")
    add suffix (TEMP"1","&lt;/a>")	
    `
	} else	if(selectedTransform==='convert to lower case'){
		newLine =`<font color="gray"><i>    #TRANSFORM ${lineNumber}: Change all to lower case.</i></font>    
    lower case (TEMP"1")<br>`
	} else if(selectedTransform==='remove numbers'){
	
	newLine =`<font color="gray"><i>    #TRANSFORM ${lineNumber}: Remove all numbers.</i></font>
    remove string (TEMP"1","[0-9]")<br>`
	}	else if(selectedTransform==='remove brackets'){
	
	newLine =`<font color="gray"><i>    #TRANSFORM ${lineNumber}: Remove bracket/parentheses and everything inside.</i></font>
<font color="gray"><i>    #e.g. 'Jonathan (John) Smith' --> 'Jonathan Smith'</i></font>
    remove substring using regex (TEMP"1","\\((.*?)\\)")<br>`
	}	else if(selectedTransform==='convert to title case'){
		
	newLine =`<font color="gray"><i>    #TRANSFORM ${lineNumber}: Replace lower case letter with upper case at the beginnining of each word. Use 'lower case' rule beforehand for best results.</i></font>
<font color="gray"><i>    #e.g. 'john doe' --> 'John Doe'</i></font>
    replace string by string (TEMP"1","\\ba","A")
    replace string by string (TEMP"1","\\bb","B")
    replace string by string (TEMP"1","\\bc","C")
    replace string by string (TEMP"1","\\bd","D")
    replace string by string (TEMP"1","\\be","E")
    replace string by string (TEMP"1","\\bf","F")
    replace string by string (TEMP"1","\\bg","G")
    replace string by string (TEMP"1","\\bh","H")
    replace string by string (TEMP"1","\\bi","I")
    replace string by string (TEMP"1","\\bj","J")
    replace string by string (TEMP"1","\\bk","K")
    replace string by string (TEMP"1","\\bl","L")
    replace string by string (TEMP"1","\\bm","M")
    replace string by string (TEMP"1","\\bn","N")
    replace string by string (TEMP"1","\\bo","O")
    replace string by string (TEMP"1","\\bp","P")
    replace string by string (TEMP"1","\\bq","Q")
    replace string by string (TEMP"1","\\br","R")
    replace string by string (TEMP"1","\\bs","S")
    replace string by string (TEMP"1","\\bt","T")
    replace string by string (TEMP"1","\\bu","U")
    replace string by string (TEMP"1","\\bv","V")
    replace string by string (TEMP"1","\\bw","W")
    replace string by string (TEMP"1","\\bx","X")
    replace string by string (TEMP"1","\\by","Y")
    replace string by string (TEMP"1","\\bz","Z")
`
	}else if(selectedTransform==='convert to upper case'){
		
	newLine =`<font color="gray"><i>    #TRANSFORM ${lineNumber}: Convert everything to upper case.</i></font>
    replace string by string (TEMP"1","a","A")
    replace string by string (TEMP"1","b","B")
    replace string by string (TEMP"1","c","C")
    replace string by string (TEMP"1","d","D")
    replace string by string (TEMP"1","e","E")
    replace string by string (TEMP"1","f","F")
    replace string by string (TEMP"1","g","G")
    replace string by string (TEMP"1","h","H")
    replace string by string (TEMP"1","i","I")
    replace string by string (TEMP"1","j","J")
    replace string by string (TEMP"1","k","K")
    replace string by string (TEMP"1","l","L")
    replace string by string (TEMP"1","m","M")
    replace string by string (TEMP"1","n","N")
    replace string by string (TEMP"1","o","O")
    replace string by string (TEMP"1","p","P")
    replace string by string (TEMP"1","q","Q")
    replace string by string (TEMP"1","r","R")
    replace string by string (TEMP"1","s","S")
    replace string by string (TEMP"1","t","T")
    replace string by string (TEMP"1","u","U")
    replace string by string (TEMP"1","v","V")
    replace string by string (TEMP"1","w","W")
    replace string by string (TEMP"1","x","X")
    replace string by string (TEMP"1","y","Y")
    replace string by string (TEMP"1","z","Z")
`
	}
	transformCounter+=1;
    transformLine.push(newLine);
    updateFunctionLine();
	
	console.log(transformCounter);
}

// Function to remove the last line from the array
function removeLine() {
    transformLine.pop();
	transformCounter-=1;
	
	if(transformCounter<0){
	   transformCounter=0;
   }
    updateFunctionLine();
	

	
	
	console.log(transformCounter);
}


// Function to update the combined text in the functionLine variable
function updateFunctionLine() {
    // Define the static text
 
    
    // Join the array elements into a single string with line breaks
    const dynamicContent = transformLine
	//.map((line, index) => `${line} (position: ${index})`)
	.join('<br>');
    
    // Combine the static and dynamic content
    transformText = dynamicContent;
  if(transformCounter===0){
	   transformText=`    <font color="gray"><i>##Insert transformation actions here</i></font>`;
   }
    // Optionally, display it in the div for visual feedback (can be removed if not needed)
    //document.getElementById('outputRule').innerHTML = functionLine;
	generateRuleFromHighlightedRow();
}



//TEST

 var amendedXPathConditionBackup='Xpath';

 function amendXPathConditionAttr() {
  // Assuming amendedXPathCondition already has a value
  
  // Regular expression to match the XPath with an attribute at the end
  var attributeRegex = /(.+)\/@([\w:]+)$/;

  // Check if the XPath matches the pattern
  var match = amendedXPathCondition.match(attributeRegex);

  if (match) {
    // Construct the amended XPath with the highlightedValue
    amendedXPathCondition = `${match[1]}[@${match[2]}='</font><font color='orange'>${highlightedValue1}</font><font color='blue'>']`;
  }

  // The amendedXPathCondition is now updated
  console.log(amendedXPathCondition);
  //generateRuleFromHighlightedRow();
  return amendedXPathCondition;
}
 
 var amendedXPathFunctionBackup='Xpath';
 function amendXPathFunctionAttr() {
	 
	//amendedXPathFunctionBackup=amendedXPathFunction;
  // Assuming amendedXPathCondition already has a value
  
  // Regular expression to match the XPath with an attribute at the end
  var attributeRegex = /(.+)\/@([\w:]+)$/;

  // Check if the XPath matches the pattern
  var match = amendedXPathFunction.match(attributeRegex);

  if (match) {
    // Construct the amended XPath with the highlightedValue
    amendedXPathFunction = `${match[1]}[@${match[2]}='</font><font color='orange'>${highlightedValue2}</font><font color='red'>']`;
  }

  // The amendedXPathCondition is now updated
  console.log(amendedXPathFunction);
  //generateRuleFromHighlightedRow();
  return amendedXPathFunction;
}
 
 
 let highlightedValue1='Xpath Value';
 let highlightedValue2='Xpath Value';
 
 
 function getHighlightedValue1() {
  // Get the highlighted line element
  const highlightedLineDiv = document.querySelector('.line.highlighted');

  // Get the highlighted XPath element
  const selectXPathDiv = document.querySelector('.selectxpathdiv.highlighted');

  if (highlightedLineDiv) {
    // Find the content within the highlighted element
    const highlightedContent = highlightedLineDiv.textContent.trim();

    // Use a regular expression to remove leading numbers and spaces
    const cleanedContent = highlightedContent.replace(/^\d+\s*/, '');

    // Get the XPath from .selectxpathdiv.highlighted
    let highlightedXPath = '';
    if (selectXPathDiv) {
      highlightedXPath = selectXPathDiv.textContent.trim();
	  console.log("highlighted1-1"+highlightedXPath)
    }

    
    if (highlightedXPath.includes("[@") && highlightedXPath.endsWith("']")) {
        // Use a regular expression to remove the part matching [@...']
        highlightedXPath = highlightedXPath.replace(/\[@[^']*'\]/, '');
		
		if (highlightedXPath.includes("[@")) {
    // Split the string at '[@' and take the part before it
		highlightedXPath = highlightedXPath.split('[@')[0];
		}
		
    }

    //let highlightedValue;

    // Check if the XPath refers to an attribute
    if (highlightedXPath.includes('@')) {
      // Extract attribute name from XPath
      const attributeName = highlightedXPath.split('@')[1];
      console.log("highlighted1-2"+highlightedXPath)
      // Extract the attribute value using a regular expression
      const attributeRegex = new RegExp(`${attributeName}="([^"]*)"`);
      const attributeMatch = cleanedContent.match(attributeRegex);

      if (attributeMatch) {
        highlightedValue1 = attributeMatch[1]; // Get the attribute value
      } else {
        highlightedValue1 = null; // No attribute value found
      }
    } else {
      // Handle case where XPath refers to element content
      // Create a temporary DOM element to parse the highlighted content
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = cleanedContent;
console.log("cleancontent1"+cleanedContent)
      // Extract the text content from the first child element (the main content)
      const textContent = tempDiv.textContent.trim();

      highlightedValue1 = textContent;
    }

    // Log the stored value to confirm
    console.log('Stored value: ' + highlightedValue1);

    // Return the stored value
    return highlightedValue1;
  } else {
    console.log('No highlighted element found.');
    return null;
  }
}
 
 

 function getHighlightedValue2() {
  // Get the highlighted line element
  const highlightedLineDiv = document.querySelector('.line.highlighted');

  // Get the highlighted XPath element
  const selectXPathDiv = document.querySelector('.selectxpathdiv.highlighted');

  if (highlightedLineDiv) {
    // Find the content within the highlighted element
    const highlightedContent = highlightedLineDiv.textContent.trim();

    // Use a regular expression to remove leading numbers and spaces
    const cleanedContent = highlightedContent.replace(/^\d+\s*/, '');

    // Get the XPath from .selectxpathdiv.highlighted
	let highlightedXPath2 = '';
    let highlightedXPath = '';
    if (selectXPathDiv) {
		
      highlightedXPath = selectXPathDiv.textContent.trim();
	  if (highlightedXPath.includes("[@")) {
    // Split the string at '[@' and take the part before it
		highlightedXPath = highlightedXPath.split('[@')[0];
		}
	  console.log("highlighted2-1"+highlightedXPath)
    }
   
    //let highlightedValue;

    // Check if the XPath refers to an attribute
    if (highlightedXPath.includes('@')) {
		console.log("highlighted2-2"+highlightedXPath)
      // Extract attribute name from XPath
      const attributeName = highlightedXPath.split('@')[1];
      
      // Extract the attribute value using a regular expression
      const attributeRegex = new RegExp(`${attributeName}="([^"]*)"`);
      const attributeMatch = cleanedContent.match(attributeRegex);

      if (attributeMatch) {
        highlightedValue2 = attributeMatch[1]; // Get the attribute value
      } else {
        highlightedValue2 = null; // No attribute value found
      }
    } else {
      // Handle case where XPath refers to element content
      // Create a temporary DOM element to parse the highlighted content
  
